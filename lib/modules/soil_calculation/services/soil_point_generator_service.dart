import 'dart:math';
import 'package:flutter/foundation.dart';
import 'package:latlong2/latlong.dart';
import '../models/soil_compaction_point_model.dart';

/// Servi칞o para gera칞칚o autom치tica de pontos de coleta dentro do pol칤gono do talh칚o
class SoilPointGeneratorService {
  static const double AREA_POR_PONTO = 10.0; // hectares
  
  /// Gera pontos de coleta automaticamente dentro do pol칤gono
  /// 
  /// [talhaoId] - ID do talh칚o
  /// [polygonCoordinates] - Coordenadas do pol칤gono do talh칚o
  /// [areaHectares] - 츼rea total do talh칚o em hectares
  /// 
  /// Retorna lista de pontos georreferenciados
  static List<SoilCompactionPointModel> gerarPontosAutomaticos({
    required int talhaoId,
    required List<LatLng> polygonCoordinates,
    required double areaHectares,
    int? safraId,
  }) {
    if (polygonCoordinates.length < 3) {
      throw Exception('Pol칤gono inv치lido: necess치rio pelo menos 3 pontos');
    }
    
    // Calcula n칰mero de pontos necess치rios
    int numeroPontos = (areaHectares / AREA_POR_PONTO).ceil();
    
    if (kDebugMode) {
      print('游깴 Gerando $numeroPontos pontos para 치rea de $areaHectares ha');
    }
    
    // Calcula limites do pol칤gono (bounding box)
    final bounds = _calcularBoundingBox(polygonCoordinates);
    
    // Gera pontos usando distribui칞칚o uniforme aleat칩ria dentro do pol칤gono
    List<SoilCompactionPointModel> pontos = [];
    int tentativas = 0;
    int maxTentativas = numeroPontos * 100; // Limite de seguran칞a
    
    while (pontos.length < numeroPontos && tentativas < maxTentativas) {
      tentativas++;
      
      // Gera coordenada aleat칩ria dentro do bounding box
      final lat = bounds['minLat']! + 
                  Random().nextDouble() * (bounds['maxLat']! - bounds['minLat']!);
      final lng = bounds['minLng']! + 
                  Random().nextDouble() * (bounds['maxLng']! - bounds['minLng']!);
      
      final ponto = LatLng(lat, lng);
      
      // Verifica se o ponto est치 dentro do pol칤gono
      if (_pontoEstaNoPoligono(ponto, polygonCoordinates)) {
        // Verifica se n칚o est치 muito pr칩ximo de outro ponto
        if (_pontoEstaDistante(ponto, pontos)) {
          pontos.add(SoilCompactionPointModel(
            pointCode: 'C-${(pontos.length + 1).toString().padLeft(3, '0')}',
            talhaoId: talhaoId,
            safraId: safraId,
            dataColeta: DateTime.now(),
            latitude: lat,
            longitude: lng,
            isAutoGenerated: true,
            profundidadeInicio: 0,
            profundidadeFim: 20, // Profundidade padr칚o 0-20cm
          ));
        }
      }
    }
    
    if (pontos.length < numeroPontos) {
      if (kDebugMode) {
        print('丘멆잺 Aviso: Gerados apenas ${pontos.length} de $numeroPontos pontos solicitados');
      }
    }
    
    return pontos;
  }
  
  /// Calcula o bounding box (ret칙ngulo envolvente) do pol칤gono
  static Map<String, double> _calcularBoundingBox(List<LatLng> polygon) {
    double minLat = polygon[0].latitude;
    double maxLat = polygon[0].latitude;
    double minLng = polygon[0].longitude;
    double maxLng = polygon[0].longitude;
    
    for (var coord in polygon) {
      if (coord.latitude < minLat) minLat = coord.latitude;
      if (coord.latitude > maxLat) maxLat = coord.latitude;
      if (coord.longitude < minLng) minLng = coord.longitude;
      if (coord.longitude > maxLng) maxLng = coord.longitude;
    }
    
    return {
      'minLat': minLat,
      'maxLat': maxLat,
      'minLng': minLng,
      'maxLng': maxLng,
    };
  }
  
  /// Verifica se um ponto est치 dentro do pol칤gono usando o algoritmo Ray Casting
  static bool _pontoEstaNoPoligono(LatLng ponto, List<LatLng> polygon) {
    int intersections = 0;
    int n = polygon.length;
    
    for (int i = 0; i < n; i++) {
      LatLng p1 = polygon[i];
      LatLng p2 = polygon[(i + 1) % n];
      
      // Verifica se o raio horizontal cruza a aresta
      if ((p1.latitude > ponto.latitude) != (p2.latitude > ponto.latitude)) {
        double xIntersect = (p2.longitude - p1.longitude) * 
                           (ponto.latitude - p1.latitude) / 
                           (p2.latitude - p1.latitude) + p1.longitude;
        
        if (ponto.longitude < xIntersect) {
          intersections++;
        }
      }
    }
    
    // Se n칰mero de interse칞칫es for 칤mpar, o ponto est치 dentro
    return intersections % 2 == 1;
  }
  
  /// Verifica se um ponto est치 distante o suficiente dos outros pontos
  static bool _pontoEstaDistante(
    LatLng novoPonto, 
    List<SoilCompactionPointModel> pontosExistentes,
  ) {
    const double distanciaMinima = 50.0; // metros
    
    for (var pontoExistente in pontosExistentes) {
      final distancia = _calcularDistancia(
        novoPonto.latitude,
        novoPonto.longitude,
        pontoExistente.latitude,
        pontoExistente.longitude,
      );
      
      if (distancia < distanciaMinima) {
        return false;
      }
    }
    
    return true;
  }
  
  /// Calcula dist칙ncia entre dois pontos usando f칩rmula de Haversine
  static double _calcularDistancia(
    double lat1, 
    double lon1, 
    double lat2, 
    double lon2,
  ) {
    const double earthRadius = 6371000; // metros
    
    double dLat = _toRadians(lat2 - lat1);
    double dLon = _toRadians(lon2 - lon1);
    
    double a = sin(dLat / 2) * sin(dLat / 2) +
               cos(_toRadians(lat1)) * cos(_toRadians(lat2)) *
               sin(dLon / 2) * sin(dLon / 2);
    
    double c = 2 * atan2(sqrt(a), sqrt(1 - a));
    
    return earthRadius * c;
  }
  
  static double _toRadians(double degrees) {
    return degrees * pi / 180;
  }
  
  /// Gera pontos em grid regular (alternativa ao m칠todo aleat칩rio)
  static List<SoilCompactionPointModel> gerarPontosEmGrid({
    required int talhaoId,
    required List<LatLng> polygonCoordinates,
    required double areaHectares,
    int? safraId,
  }) {
    int numeroPontos = (areaHectares / AREA_POR_PONTO).ceil();
    
    // Calcula dimens칫es do grid
    int linhas = sqrt(numeroPontos).ceil();
    int colunas = (numeroPontos / linhas).ceil();
    
    final bounds = _calcularBoundingBox(polygonCoordinates);
    
    double stepLat = (bounds['maxLat']! - bounds['minLat']!) / (linhas + 1);
    double stepLng = (bounds['maxLng']! - bounds['minLng']!) / (colunas + 1);
    
    List<SoilCompactionPointModel> pontos = [];
    int pontoCodigo = 1;
    
    for (int i = 1; i <= linhas; i++) {
      for (int j = 1; j <= colunas; j++) {
        if (pontos.length >= numeroPontos) break;
        
        double lat = bounds['minLat']! + (i * stepLat);
        double lng = bounds['minLng']! + (j * stepLng);
        
        final ponto = LatLng(lat, lng);
        
        if (_pontoEstaNoPoligono(ponto, polygonCoordinates)) {
          pontos.add(SoilCompactionPointModel(
            pointCode: 'C-${pontoCodigo.toString().padLeft(3, '0')}',
            talhaoId: talhaoId,
            safraId: safraId,
            dataColeta: DateTime.now(),
            latitude: lat,
            longitude: lng,
            isAutoGenerated: true,
            profundidadeInicio: 0,
            profundidadeFim: 20,
          ));
          pontoCodigo++;
        }
      }
    }
    
    return pontos;
  }
}

